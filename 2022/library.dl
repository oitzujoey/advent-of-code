
(var duckLisp-object-type-none 0)
(var duckLisp-object-type-bool 1)
(var duckLisp-object-type-int 2)
(var duckLisp-object-type-float 3)
(var duckLisp-object-type-str 4)
(var duckLisp-object-type-list 5)
(var duckLisp-object-type-symbol 6)
(var duckLisp-object-type-function 7)
(var duckLisp-object-type-closure 8)

(comment " Copied straight out of CLHS Bï¼‰")

(defun caar (x)
  (car (car x)))
(defun cadr (x)
  (car (cdr x)))
(defun cdar (x)
  (cdr (car x)))
(defun cddr (x)
  (cdr (cdr x)))
(defun caaar (x)
  (car (car (car x))))
(defun caadr (x)
  (car (car (cdr x))))
(defun cadar (x)
  (car (cdr (car x))))
(defun caddr (x)
  (car (cdr (cdr x))))
(defun cdaar (x)
  (cdr (car (car x))))
(defun cdadr (x)
  (cdr (car (cdr x))))
(defun cddar (x)
  (cdr (cdr (car x))))
(defun cdddr (x)
  (cdr (cdr (cdr x))))
(defun caaaar (x)
  (car (car (car (car x)))))
(defun caaadr (x)
  (car (car (car (cdr x)))))
(defun caadar (x)
  (car (car (cdr (car x)))))
(defun caaddr (x)
  (car (car (cdr (cdr x)))))
(defun cadaar (x)
  (car (cdr (car (car x)))))
(defun cadadr (x)
  (car (cdr (car (cdr x)))))
(defun caddar (x)
  (car (cdr (cdr (car x)))))
(defun cadddr (x)
  (car (cdr (cdr (cdr x)))))
(defun cdaaar (x)
  (cdr (car (car (car x)))))
(defun cdaadr (x)
  (cdr (car (car (cdr x)))))
(defun cdadar (x)
  (cdr (car (cdr (car x)))))
(defun cdaddr (x)
  (cdr (car (cdr (cdr x)))))
(defun cddaar (x)
  (cdr (cdr (car (car x)))))
(defun cddadr (x)
  (cdr (cdr (car (cdr x)))))
(defun cdddar (x)
  (cdr (cdr (cdr (car x)))))
(defun cddddr (x)
  (cdr (cdr (cdr (cdr x)))))

(defun first (list)
  (car list))
(defun second (list)
  (car (cdr list)))
(defun third (list)
  (car (cddr list)))
(defun fourth (list)
  (car (cdddr list)))
(defun fifth (list)
  (car (cddddr list)))
(defun sixth (list)
  (car (cdr (cddddr list))))
(defun seventh (list)
  (car (cddr (cddddr list))))
(defun eighth (list)
  (car (cdddr (cddddr list))))
(defun ninth (list)
  (car (cddddr (cddddr list))))
(defun tenth (list)
  (car (cdr (cddddr (cddddr list)))))

(defun rest (x)
  (cdr x))

(defun print (&rest vs)
  (var vs2 vs)
  (while (not (null? vs2))
    (print (car vs2))
    (setq vs2 (cdr vs2)))
  vs)

(defun println (&rest vs)
  (apply print vs)
  (print "\n")
  vs)

(defmacro to (variable form)
  (var function (car form))
  (var args (cdr form))
  (var subform (list function variable))
  (set-cdr (cdr subform) args)
  (list (quote setq) variable subform))

(defun identity (x) x)

(defun 1+ (x)
  (+ x 1))

(defun 1- (x)
  (- x 1))

(defun >= (x y)
  (not (< x y)))

(defun <= (x y)
  (not (> x y)))

(defun != (x y)
  (not (= x y)))

(defun even? (value)
  (= 0 (- value (* (/ value 2) 2))))
(defun odd? (value)
  (not (even? value)))

(defun mod (a b)
  (- a (* (/ a b) b)))

(defun gcd (a b)
  (while (not (= a b))
    (if (> a b)
        (to a (- b))
        (to b (- a))))
  a)

(defun lcm (a b)
  (* a (/ b (gcd a b))))

(defmacro push (value variable)
  (list (quote setq) variable (list (quote cons) value variable)))

(defmacro pop (variable)
  (list (quote setq) variable (list (quote cdr) variable)))

(defun length (list)
  (var i 0)
  (while (not (null? list))
    (to list (cdr))
    (to i (1+)))
  i)

(defun nreverse (list)
  (var reversed-list ())
  (while (not (null? list))
    (setq reversed-list (cons (car list)
                              reversed-list))
    (to list (cdr)))
  reversed-list)

(defun max (&rest values)
  (var max-value (first values))
  (pop values)
  (while (not (null? values))
         (var value (first values))
         (when (> value max-value)
           (setq max-value value))
         (pop values))
  max-value)

(defun sort-descending (list)
  (quicksort-hoare list (length list)))

(defun sort-ascending (list)
  (nreverse (quicksort-hoare list (length list))))

(defun integer? (value)
  (= (type-of value) duckLisp-object-type-int))

(comment (defun type-to-string (type)
           (switch type
                   duckLisp-object-type-none "none"
                   duckLisp-object-type-bool "bool"
                   duckLisp-object-type-int "int"
                   duckLisp-object-type-float "float"
                   duckLisp-object-type-str "str"
                   duckLisp-object-type-list "list"
                   duckLisp-object-type-symbol "sym"
                   duckLisp-object-type-function "func"
                   duckLisp-object-type-closure "clos")))

(defun type-to-string (type)
  (if (= type duckLisp-object-type-none)
      "none"
      (if (= type duckLisp-object-type-bool)
          "bool"
          (if (= type duckLisp-object-type-int)
              "int"
              (if (= type duckLisp-object-type-float)
                  "float"
                  (if (= type duckLisp-object-type-str)
                      "str"
                      (if (= type duckLisp-object-type-list)
                          "list"
                          (if (= type duckLisp-object-type-symbol)
                              "sym"
                              (if (= type duckLisp-object-type-function)
                                  "func"
                                  (if (= type duckLisp-object-type-closure)
                                      "clos"
                                      "Invalid type"))))))))))

(defun and (a b)
  (if a
      (if b
          true
          false)
      false))

(defun or (a b)
  (if a
      true
      (if b
          true
          false)))

(defun atom? (v)
  (or (not (= (type-of v) duckLisp-object-type-list))
      (null? v)))

(defun subst (x y z)
  (if (atom? z)
      (if (= z y)
          x
          z)
      (cons (self x y (car z))
            (self x y (cdr z)))))

(defun pair (x y)
  (if (and (null? x) (null? y))
      ()
      (if (and (not (atom? x)) (not (atom? y)))
          (cons (cons (car x) (cons (car y) ()))
                (self (cdr x) (cdr y)))
          ())))

(defun assoc (x y)
  (var duckLisp-object-type-list 5)
  (if (not (null? y))
      (if (= (car (car y)) x)
          (car (cdr (car y)))
          (self x (cdr y)))
      ()))

(defun nthcdr (n list)
  (var i 0)
  (while (< i n)
    (to list (cdr))
    (to i (1+)))
  list)

(defun nth (n list)
  (var i 0)
  (while (< i n)
    (to list (cdr))
    (to i (1+)))
  (car list))

(defun elt (list n)
  (nth n list))

(defun last (list)
  (car (nreverse list)))

(defun append (list1 list2)
  (var appended-list ())
  (while (not (null? list1))
    (setq appended-list (cons (car list1)
                              appended-list))
    (to list1 (cdr)))
  (while (not (null? list2))
    (setq appended-list (cons (car list2)
                              appended-list))
    (to list2 (cdr)))
  (nreverse appended-list))

(defun copy-list (list)
  (var new-list ())
  (while (not (null? list))
         (setq new-list (cons (car list) new-list))
         (to list (cdr)))
  (nreverse new-list))

(defun member (element list)
  (var found false)
  (while (and (not (null? list)) (not found))
    (if (= element (car list))
        (setq found true)
        ())
    (to list (cdr)))
  found)

(defun remove-if (fun list)
  (unless (null? list)
      (if (fun (car list))
          (self fun (cdr list))
          (cons (car list)
                (self fun (cdr list))))))

(defun remove-if-not (fun list)
  (unless (null? list)
      (if (not (fun (car list)))
          (self fun (cdr list))
          (cons (car list)
                (self fun (cdr list))))))

(defun maplist (fun list)
  (unless (null? list)
      (cons (fun list) (self fun (cdr list)))))

(defun mapcar (fun list)
  (unless (null? list)
    (cons (fun (car list)) (self fun (cdr list)))))

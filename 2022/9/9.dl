(include "../aoclib.dl")

(part 1)

(defun make-vec2 (x y)
  (cons x y))

(defun vec2-x (v)
  (car v))

(defun vec2-y (v)
  (cdr v))

(defun vec2-add (&rest vs)
  (var sum (make-vec2 0 0))
  (dolist (v vs sum)
    (setq sum (make-vec2 (+ (vec2-x sum) (vec2-x v))
                         (+ (vec2-y sum) (vec2-y v))))))

(defun vec2-sub (&rest vs)
  (var diff (pop vs))
  (dolist (v vs diff)
    (setq diff (make-vec2 (- (vec2-x diff) (vec2-x v))
                          (- (vec2-y diff) (vec2-y v))))))

(defun vec2-equal (&rest vs)
  (var equal true)
  (var first (pop vs))
  (dolist (v vs equal)
    (when (or (!= (vec2-x first) (vec2-x v))
              (!= (vec2-y first) (vec2-y v)))
      (setq equal false))))

(defun vec2-hash (v)
  (var large-prime 7919)
  (comment Map two dimensional integer vector onto the whole numbers.)
  (var x (* (vec2-x v) 2))
  (var y (* (vec2-y v) 2))
  (when (< x 0)
    (setq x (- 1 x)))
  (when (< y 0)
    (setq y (- 1 y)))
  (+ (* x large-prime) y))

(defun abs (n)
  (if (< n 0) (- 0 n) n))

(var large-prime 17389)

(var move ())
(defun U (n)
  (move (make-vec2  0  1) n))
(defun D (n)
  (move (make-vec2  0 -1) n))
(defun L (n)
  (move (make-vec2 -1  0) n))
(defun R (n)
  (move (make-vec2  1  0) n))


(var head-position (make-vec2 0 0))
(var tail-position (make-vec2 0 0))
(var head-log (list head-position))
(var tail-log (list tail-position))

(defun move-part1 (direction steps)
  (var last-head-position head-position)
  (defun move-head ()
    (setq last-head-position head-position)
    (to head-position (vec2-add direction))
    (push head-position head-log))
  (defun move-tail ()
    (comment One thing to note is that the head will never be more than a space away from the tail when this function is
             run.)
    (var difference (vec2-sub head-position tail-position))
    (var x-diff (vec2-x difference))
    (var y-diff (vec2-y difference))
    (when (or (> (abs x-diff) 1)
              (> (abs y-diff) 1))
      (if (or (and (= x-diff 0) (!= y-diff 0))
              (and (!= x-diff 0) (= y-diff 0)))
          (setq tail-position last-head-position)
          (to tail-position (vec2-add (make-vec2 (if (> x-diff 0)
                                                     1
                                                     (if (< x-diff 0)
                                                         -1
                                                         0))
                                                 (if (> y-diff 0)
                                                     1
                                                     (if (< y-diff 0)
                                                         -1
                                                         0))))))
      (push tail-position tail-log)))
  (while (> steps 0)
    (move-head)
    (move-tail)
    (println steps)
    (dec steps)
    ()))

(setq move move-part1)
(get-input false)

(defun hash-log (log)
  (var hash-table (make-hash-table large-prime vec2-hash vec2-equal))
  (dolist (entry log)
    (hash-table (quote set) entry entry))
  (hash-table (quote get-table)))

(defun flatten-hash-table-list (hash-table-list)
  (var flattened-list ())
  (while hash-table-list
    (var entry-list (car hash-table-list))
    (while entry-list
      (push (car entry-list) flattened-list)
      (pop entry-list))
    (pop hash-table-list))
  flattened-list)

(result (length (flatten-hash-table-list (hash-log tail-log))))


(part 2)
(
 (var head-position (make-vec2 0 0))
 (var tail-position (make-vec2 0 0))
 (var tail-position-refs (make-vector 9 ()))
 (
  (var i 0)
  (while (< i 8)
    (var v (make-vec2 0 0))
    (set-vector-element tail-position-refs i (ref v))
    (inc i))
  (set-vector-element tail-position-refs i (ref tail-position)))
 (var head-log (list head-position))
 (var tail-log (list tail-position))
 (var tail-log-refs (make-vector 9 ()))
 (set-vector-element tail-log-refs 8 (ref tail-log))

 (defun move-part2 (direction steps)
   (var last-head-position head-position)
   (var valid-tail-dirs (list (make-vec2  1  0)
                              (make-vec2  1 -1)
                              (make-vec2  0 -1)
                              (make-vec2 -1 -1)
                              (make-vec2 -1  0)
                              (make-vec2 -1  1)
                              (make-vec2  0  1)
                              (make-vec2  1  1)))
   (var valid-head-dirs (list (make-vec2  1  0)
                              (make-vec2  0 -1)
                              (make-vec2 -1  0)
                              (make-vec2  0  1)))
   (defun move-head ()
     (to head-position (vec2-add direction))
     (push head-position head-log))

   (defun move-tail (tail-position log-ref head-position last-head-position)
     (comment One thing to note is that the head will never be more than a space away from the tail when this function
              is run.)
     (var difference (vec2-sub head-position tail-position))
     (var x-diff (vec2-x difference))
     (var y-diff (vec2-y difference))

     (when (or (> (abs x-diff) 1)
               (> (abs y-diff) 1))
       (var found ())
       (
        (var valid-heads ())
        (var valid-tails ())
        (dolist (valid-head-dir valid-head-dirs)
          (push (vec2-add head-position valid-head-dir) valid-heads))
        (dolist (valid-tail-dir valid-tail-dirs)
          (push (vec2-add tail-position valid-tail-dir) valid-tails))
        (while (and valid-heads (not found))
          (var valid-tails2 valid-tails)
          (while (and valid-tails2 (not found))
            (when (vec2-equal (car valid-heads) (car valid-tails2))
              (setq found (car valid-heads)))
            (pop valid-tails2))
          (pop valid-heads)))
       (if found
           (setq tail-position found)
           (if (or (and (= x-diff 0) (!= y-diff 0))
                   (and (!= x-diff 0) (= y-diff 0)))
               (setq tail-position last-head-position)
               (to tail-position (vec2-add (make-vec2 (if (> x-diff 0)
                                                          1
                                                          (if (< x-diff 0)
                                                              -1
                                                              0))
                                                      (if (> y-diff 0)
                                                          1
                                                          (if (< y-diff 0)
                                                              -1
                                                              0)))))))
       (when log-ref
         (set-deref log-ref (cons tail-position (deref log-ref)))))
     tail-position)
   (while (> steps 0)
     (setq last-head-position head-position)
     (move-head)
     (var current-head head-position)
     (var current-last-head last-head-position)
     (var i 0)
     (while (< i 9)
       (var tail-log-ref (get-vector-element tail-log-refs i))
       (var tail-pos-ref (get-vector-element tail-position-refs i))
       (var next-last-head (deref tail-pos-ref))
       (set-deref tail-pos-ref (move-tail (deref tail-pos-ref) tail-log-ref current-head current-last-head))
       (set-vector-element tail-position-refs i tail-pos-ref)
       (set-vector-element tail-log-refs i tail-log-ref)
       (setq current-last-head next-last-head)
       (setq current-head (deref tail-pos-ref))
       (inc i))
     (dec steps)))

 (setq move move-part2)
 (get-input true)

 (defun hash-log (log)
   (var hash-table (make-hash-table large-prime vec2-hash vec2-equal))
   (dolist (entry log)
     (hash-table (quote set) entry entry))
   (hash-table (quote get-table)))

 (defun flatten-hash-table-list (hash-table-list)
   (var flattened-list ())
   (while hash-table-list
     (var entry-list (car hash-table-list))
     (while entry-list
       (push (car entry-list) flattened-list)
       (pop entry-list))
     (pop hash-table-list))
   flattened-list)

 (println tail-log)
 (println (mapcar* first (flatten-hash-table-list (hash-log tail-log))))

 (result (length (flatten-hash-table-list (hash-log tail-log)))))
